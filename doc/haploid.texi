\input texinfo                  @c -*-texinfo-*-
@comment $Id$
@comment %**start of header
@setfilename haploid.info
@include version.texi
@settitle Numerical Library for Haploid Genetics 
@syncodeindex pg cp
@comment %**end of header
@copying
This manual is for Haploid (version @value{VERSION}, @value{UPDATED}), a
C library for haploid population genetic simulations.

Copyright @copyright{} 2009 Joel J. Adamson

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections, with the Front-Cover Texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the license is
included in the section entitled ``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to
copy and modify this GNU manual.''
@end quotation
@end copying

@dircategory Libraries
@direntry
* Haploid: (haploid). Numerical Library for Haploid Genetics.
@end direntry

@titlepage
@title  Numerical Library for Haploid Genetics
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Joel J. Adamson (@email{adamsonj@@email.unc.edu})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Numerical Library for Haploid Genetics

This manual covers Haploid (version @value{VERSION}, @value{UPDATED}), a
C library for haploid population genetic simulations.

@menu
* Introduction::                
* Representation::              
* Simulation functions::        
* GNU Free Documentation License::  
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Development::                 

Representation

* Genotypes::                   
* Compound Objects::            

Genotypes

* Working with genome size::    
* Manipulating Genotypes::      
* Genotype functions::          

@end detailmenu
@end menu

@end ifnottex

@comment  node-name,  next,  previous,  up
@node Introduction, Representation, Top, Top
@chapter Introduction
Haploid is a library of C functions useful for simulating haploid
population genetics.  Haploid simulations are often used for theoretical
studies of sexual selection, migration and speciation.

Haploid follows the GNU Coding Standards and is managed by the GNU
Autotools in a @url{http://subversion.tigris.org, Subversion} version
control repository hosted on
@url{http://savannah.nongnu.org/projects/haploid, Savannah}.

To use the library, use @code{#include <haploid.h>} at the top of your
files.  To link with the library, pass @code{-lhaploid} to the linker.
For example:

@example
# gcc -std=gnu99 -ggdb  -g -O2   -o sim_stop sim_stop.o -lm -lhaploid 
@end example

Haploid is Free Software released under the terms of the GNU General
Public License Version 3.

Send bug reports or questions on usage to the mailing list at
@email{haploid-users@@nongnu.org}).

@menu
* Development::                 
@end menu

@node Development,  , Introduction, Introduction
@section Development

@comment Some details of developing Haploid.

Please read the GNU Coding Standards before adding any code to Haploid
or developing a test. @xref{Writing C, Writing C, Writing C, standards,
GNU Coding Standards}, for details of GNU style.  Haploid makes use of
extensions in the GNU C Library and the C99 Standard.  I also highly
recommend using GCC for compiling the library, as some library functions
are merely wrappers for builtin functions available in GCC.

Patches are welcomed for testing.  The best way to make a patch from
your working copy is with the command

@example
# svn diff -x -u <filename> > PATCHFILE
@end example

Such a diff contains enough information for @command{patch} to apply it
with

@example
# patch -p0 < PATCHFILE
@end example

@node Representation, Simulation functions, Introduction, Top
@chapter Representation

Haploid represents two kinds of objects: diallelic genotypes (integers),
which can be considered atomic (they can be created and destroyed easily
and there is no need to save them) and compound objects that represent
interactions of genotypes.  Many functions use variable length arrays
internally, hence the GNU99 standard.  All functions documented here are
defined in @file{haploid.h}.

@menu
* Genotypes::                   
* Compound Objects::            
@end menu

@node Genotypes, Compound Objects, Representation, Representation
@section Genotypes

Haploid represents diallelic genomes with unsigned C integers: a single
locus (position) is represented by a bit of an integer.  An n-locus
genotype therefore has @math{2^n} possible genotypes.  We can therefore
represent all interactions of genotypes (e.g. mating, mutation, etc) as
changes to bits of integers.  The frequency assigned to a particular
locus is the frequency of the set bit (1), and one minus the frequency
of an unset bit.

This makes iterating over genotypes @strong{very} convenient, as you can
start iterating at 0, and stop before a genotype equals the maximum
number of genotypes.  For a genome with @math{n} loci, you will
therefore iterate over @math{2^n} genotypes.

@menu
* Working with genome size::    
* Manipulating Genotypes::      
* Genotype functions::          
@end menu

@node Working with genome size, Manipulating Genotypes, Genotypes, Genotypes
@subsection  Working with genome size

The simplest way to represent the size of a genome and the number of
alleles is to define global variables or macros to use as array bounds.
Here's an example from @file{tests/tlta.c}:
@example

@verbatim
#define GENO 4			/* GENO */

void
selection (double * freqs, double * W)
{
  /* selection step: Multiply each genotype frequency by its
     respective fitness, then divide by the mean fitness  */

  /* new frequencies after selection step */
  double wbar = gen_mean (freqs, W, GENO);
  /* selection: */
  for (int i = 0; i < GENO; i++)
    /* update freqs with new frequencies */
    freqs[i] = freqs[i] * W[i] / wbar;
}
@end verbatim
@end example


@node Manipulating Genotypes, Genotype functions, Working with genome size, Genotypes
@subsection Manipulating Genotypes

Haploid includes some basic functions that operate on bits of integers:
you may find these functions useful for defining specific loci with
particular phenotypic effects within a large genome.  For example, you
could have a set of loci defined at positions 0--3 of a genotype
(genotypes 0x0--0xf) that code for an additive phenotype, and other
single-locus traits in the same genotype.

@deftypefn {Library Function} _Bool bits_isset (int x, @
           unsigned int pos)

Test if the bit at position @var{pos} is set; if so, return @code{true},
if not return @code{false}.
@end deftypefn

@deftypefn {Library Function} unsigned int bits_extract @
           (unsigned int start, unsigned int end, unsigned int x)
           
Return an unsigned integer extracted from a section of the unsigned
integer @var{x} defined by @var{start} (inclusive) until @var{end}
(exclusive).
@end deftypefn

@deftypefn {Library Function} unsigned int bits_popcount (int x)

Return the number of set bits in @var{x}.  If you compile with GNU
Compiler Collection, this function simply returns the result of
__builtin_popcount (@var{x}) (@pxref{Other Builtins, GCC,, gcc, GNU
Compiler Collection Manual}).
@end deftypefn

@deftypefn {Library Function} unsigned int bits_ffs (unsigned int x)

Return the 1-indexed position of the least significant bit.  In other
words, @code{bits_ffs(2)} returns the integer @math{2}.  This function
is a wrapper for __builtin_ffs () (@pxref{Other Builtins, GCC,, gcc, GNU
Compiler Collection Manual}).  If compiled with GCC, this function
simply returns the result of __builtin_ffs ().
@end deftypefn

@node Genotype functions,  , Manipulating Genotypes, Genotypes
@subsection Genotype functions

@deftypefn {Library Function} void allele_to_genotype @
(double * allele_freqs, double * geno_freqs, size_t nloci, size_t geno)

@code{allele_to_genotype} takes an array of allele frequencies
@var{allele_freqs} and assigns values of random-union-of-gametes
genotype frequencies to @var{geno_freqs}.  The integers @var{nloci} and
@var{geno} serve as array bounds for @var{allele_freqs} and
@var{geno_freqs}, respectively.  The allele frequencies in
@var{allele_freqs} are the frequencies of set bits for the @math{0}
(first) to @math{n-1} (nth) loci of an n-locus genome.  This function
only returns valid results for randomly mating populations, so it is
only useful for certain cases, e.g. producing initial frequencies of
genotypes when it is most convenient to assign to alleles instead of
genotypes.

@example
@verbatim
#define NLOCI 2			/* NLOCI */
#define GENO 4			/* GENO */

double freq[GENO];
double allele[NLOCI];

srand48 (0);
for (j = 0; j < NLOCI; j++)
  allele[j] = drand48 ();

allele_to_genotype (allele, freq, NLOCI, GENO);
@end verbatim
@end example

@end deftypefn

@deftypefn {Library Function} void genotype_to_allele @
(double * allele_freqs, double * geno_freqs, size_t nloci, size_t geno)

@code{genotype_to_allele} takes an array of genotype frequencies
@var{geno_freqs} and uses it to store allele frequencies in
@var{allele_freqs}.  The formal parameters have the same meaning as in
@code{allele_to_genotype}.  @code{genotype_to_allele} is valid in all
contexts.
@end deftypefn

@deftypefn {Library Function} double ld_from_geno@
(size_t nloci, size_t geno, double * geno_freqs)

@code{ld_from_geno} calculates linkage disequilibrium by subtracting
from the value stored at @var{geno_freqs} from the product of the allele
frequencies.  In other words, it is equivalent to
@end deftypefn

@math{f(x) - \Pi_{i=0}^{n} (1 - f(x_i))}

where @math{f(x)} is the frequency of genotype @math{x}, and
@math{f(x_i)} is the frequency of the allele at the @math{i}-th
position.


@node Compound Objects,  , Genotypes, Representation
@section Compound Objects

Compound objects represent interactions of genotypes, especially mating.
The library represents all compound objects as arrays, either single- or
multi-dimensional.  Haploid uses singly-linked lists to represent sparse
matrices (e.g. recombination tables).

The data type @code{rtable_t} is an array of sparse matrices
representing a recombination table.  

The data type @code{haploid_data_t} can hold most of the information
needed for a simulation:

@verbatim
typedef sparse_elt_t rtable_t;
typedef struct haploid_data_t haploid_data_t;
struct haploid_data_t
{
  int geno;			/* number of genotypes */
  int nloci;			/* number of loci */
  rtable_t ** rec_table;	/* recombination table */
  double ** mtable;		/* mating table (matrix) */
};
@end verbatim

@deftypefn {Library Function} rtable_t rec_gen_table @
(int nloci, int geno, double * r)

@code{rec_gen_table} returns a recombination table with entries
corresponding to the probability of producing the @math{k}-th genotype
from mating the @math{i}-th father and the @math{j}-th mother.  In other
words, each sparse matrix pointer in the returned array is a matrix
describing the probability of producing a specific offspring genotype.
@var{r} is a pointer to the recombination map (an array of recombination
probabilities between adjacent sites).  @var{r} should have
@math{@var{nloci} - 1} entries (or the first @math{@var{nloci} - 1}
entries will be used).  The usual C programming caveats apply:
if this array does not contain enough entries, it will probably contain
junk and you will get unexpected results!
@end deftypefn

@deftypefn {Library Function} double * rec_mating @
(haploid_data_t * data)

@code{rec_mating} returns a new vector of offspring frequencies from the
data in @var{data}.  
@end deftypefn

@deftypefn {Library Function} double ** rmtable (int geno, double * freq)

@code{rmtable} returns a mating table to reflect random mating,
i.e. products of the entries in @var{freq}.  @var{geno} provides the
dimensions of @var{table}.
@end deftypefn


@node Simulation functions, GNU Free Documentation License, Representation, Top
@chapter Simulation functions
Some special functions for managing simulations or doing often-needed
calculations are available.

@deftypefn {Library Function} int sim_stop_ck (double * p1, double * p2, @
int len, long double tol)

@code{sim_stop_ck} compares the values of @var{p1} and @var{p2} by
finding their Euclidean distance @math{d(p1, p2) = (\sum_{i = 0}^n
p_{1i} - p_{2i})^{1 \over 2}}, where @math{n = @var{len}}.  When @math{d
< @var{tol}}, @code{sim_stop_ck} returns 0, otherwise it returns 1.
Calls to @code{sim_stop_ck} are @strong{expensive}: you should only make
one such call per iteration, or find another way to stop your
simulation.

@end deftypefn

@deftypefn {Library Function} double gen_mean (double * props, @
double * vals, int len)

@code{gen_mean} returns the generalized mean @math{\sum_{i = 0}^{n} x
p(x)} given a pointer to proportions @var{props} and a pointer to values
@var{x}.  @var{len} gives array dimensions.

@end deftypefn



@node GNU Free Documentation License, Index, Simulation functions, Top
@appendix GNU Free Documentation License

@include fdl-1.3.texi

@node Index,  , GNU Free Documentation License, Top
@unnumbered Index

@printindex fn

@bye
